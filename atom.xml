<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-11-02T02:54:26.602Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于RocketMQ的一些内容和特性</title>
    <link href="http://example.com/2020/11/01/%E5%85%B3%E4%BA%8ERocketMQ%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9%E5%92%8C%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2020/11/01/%E5%85%B3%E4%BA%8ERocketMQ%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9%E5%92%8C%E7%89%B9%E6%80%A7/</id>
    <published>2020-11-01T07:11:07.000Z</published>
    <updated>2020-11-02T02:54:26.602Z</updated>
    
    <content type="html"><![CDATA[<p>首先是发送消息分同步和异步，</p><p>Producer的顺序消息：在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的。</p><h3 id="分布式消息："><a href="#分布式消息：" class="headerlink" title="分布式消息："></a>分布式消息：</h3><p>分布式事务分类有这几种：</p><ul><li><p>基于单个JVM，数据库分库分表了（跨多个数据库）。</p></li><li><p>基于多JVM，服务拆分了（不跨数据库）。</p></li><li><p>基于多JVM，服务拆分了 并且数据库分库分表了。</p></li></ul><p>采用半消息方式，发送消息后处理完本地事务再确认</p><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><ol><li><p>发送方向 MQ 服务端发送消息。</p></li><li><p>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</p></li><li><p>发送方开始执行本地事务逻辑。</p></li><li><p>发送方根据本地事务执行结果向 MQ Server 提交二次确认（Commit 或是 Rollback），MQ Server 收到</p></li></ol><p>Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 Rollback 状态则删除半</p><p>消息，订阅方将不会接受该消息。</p><ol start="5"><li>在断网或者是应用重启的特殊情况下，上述步骤4提交的二次确认最终未到达 MQ Server，经过固定时间后</li></ol><p>MQ Server 将对该消息发起消息回查。</p><ol start="6"><li><p>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</p></li><li><p>发送方根据检查得到的本地事务的最终状态再次提交二次确认，MQ Server 仍按照步骤4对半消息进行操作。</p></li></ol><h3 id="Consumer的Push和Pull"><a href="#Consumer的Push和Pull" class="headerlink" title="Consumer的Push和Pull"></a>Consumer的Push和Pull</h3><p>push模式：客户端与服务端建立连接后，当服务端有消息时，将消息推送到客户端。</p><p>pull模式：客户端不断的轮询请求服务端，来获取新的消息。</p><p>底层都是pull，只不过push被封装到里面，pull需要自己实现</p><p>长轮询：发送一个pull等待服务器有消息再拉取，避免了一直pull造成压力</p><p>消息模式：集群模式和广播模式</p><p>重复消息：肯定存在的，自己解决，要么设置key相同的不处理，要么处理结果相同保持为一条。</p><h3 id="RocketMQ存储"><a href="#RocketMQ存储" class="headerlink" title="RocketMQ存储"></a>RocketMQ存储</h3><p>RocketMQ中的消息数据存储，采用了零拷贝技术（使用 mmap + write 方式），文件系统采用 Linux Ext4 文件系</p><p>统进行存储。</p><p>RocketMQ消息的存储是由ConsumeQueue和CommitLog配合完成的，CommitLog是真正存储数据的文件，</p><p>ConsumeQueue是索引文件，存储数据指向到物理文件的配置。</p><p>同步刷盘和异步刷盘</p><ul><li>同步刷盘<ul><li>在返回写成功状态时，消息已经被写入磁盘 。</li><li>具体流程是：消息写入内存的 PAGECACHE 后，立刻通知刷盘线程刷盘，然后等待刷盘完成，刷盘线程</li></ul></li></ul><p>执行完成后唤醒等待的线程，返回消息写成功的状态 。</p><ul><li>异步刷盘<ul><li>在返回写成功状态时，消息可能只是被写入了内存的 PAGECACHE，写操作的返回快，吞吐量大</li><li>当内存里的消息量积累到一定程度时，统一触发写磁盘动作，快速写入。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先是发送消息分同步和异步，&lt;/p&gt;
&lt;p&gt;Producer的顺序消息：在某些业务中，consumer在消费消息时，是需要按照生产者发送消息的顺序进行消费的。&lt;/p&gt;
&lt;h3 id=&quot;分布式消息：&quot;&gt;&lt;a href=&quot;#分布式消息：&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于RocketMQ发送消息报错</title>
    <link href="http://example.com/2020/10/31/%E5%85%B3%E4%BA%8ERocketMQ%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2020/10/31/%E5%85%B3%E4%BA%8ERocketMQ%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%8A%A5%E9%94%99/</id>
    <published>2020-10-31T05:43:14.000Z</published>
    <updated>2020-10-31T05:51:01.809Z</updated>
    
    <content type="html"><![CDATA[<p>报错信息：Exception in thread “main” org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout</p><p>在虚拟机中rockermq配置完broker启动成功后信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[itcast, 172.17.0.1:10911] boot success. serializeType&#x3D;JSON and name server is 172.16.185.55:9876</span><br></pre></td></tr></table></figure><p>发现broker的ip是172.17.0.1，外部没办法访问所以必须把IP地址改掉，在虚拟机创建一个配置文件../conf/broker.conf</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brokerIP1=172.16.55.185 </span><br><span class="line">namesrvAddr=172.16.55.185:9876 </span><br><span class="line">brokerName=broker_haoke_im</span><br></pre></td></tr></table></figure><p>启动时指定配置文件 -c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;mqbroker -c &#x2F;haoke&#x2F;rmq&#x2F;rmqbroker&#x2F;conf&#x2F;broker.conf</span><br></pre></td></tr></table></figure><p>会发现成功信息变成如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The broker[itcast, 172.16.55.185:10911] boot success. serializeType&#x3D;JSON and name server is 172.16.55.185:9876</span><br></pre></td></tr></table></figure><p>通常情况下这样就可以访问了</p><hr><p>但是我的还是不行，原因是最容易被忽略的超时问题，把生产者的超时时间设置大一点就可以我这里设置15s</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.setSendMsgTimeout(<span class="number">15000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;报错信息：Exception in thread “main” org.apache.rocketmq.remoting.exception.RemotingTooMuchRequestException: sendDefaultImpl call timeout&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GraphQL学习之开发某服务接口实现</title>
    <link href="http://example.com/2020/10/30/GraphQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%80%E5%8F%91%E6%9F%90%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2020/10/30/GraphQL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%80%E5%8F%91%E6%9F%90%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-30T00:34:30.000Z</published>
    <updated>2020-11-01T01:06:38.776Z</updated>
    
    <content type="html"><![CDATA[<p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.编写haoke.graphqls文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">schema &#123; </span><br><span class="line">query: HaokeQuery </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type HaokeQuery &#123; </span><br><span class="line">HouseResources(id:Long):HouseResources </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type HouseResources&#123; </span><br><span class="line">id:Long! title:String </span><br><span class="line">estateId:Long</span><br><span class="line">  buildingNum:String </span><br><span class="line">  buildingUnit:String </span><br><span class="line">  buildingFloorNum:String </span><br><span class="line">  rent:Int </span><br><span class="line">  rentMethod:Int </span><br><span class="line">  paymentMethod:Int </span><br><span class="line">  houseType:String </span><br><span class="line">  coveredArea:String </span><br><span class="line">  useArea:String </span><br><span class="line">  floor:String </span><br><span class="line">  orientation:String </span><br><span class="line">  decoration:Int </span><br><span class="line">  facilities:String </span><br><span class="line">  pic:String houseDesc:String </span><br><span class="line">  contact:String mobile:String </span><br><span class="line">  time:Int propertyCost:String </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编写GraphQLController</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;graphql&quot;)</span> <span class="comment">//前端访问地址</span></span><br><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLController</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Autowired</span> </span><br><span class="line">  <span class="keyword">private</span> GraphQL graphQL; </span><br><span class="line">  <span class="meta">@GetMapping</span> </span><br><span class="line">  <span class="meta">@ResponseBody</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">graphql</span><span class="params">(<span class="meta">@RequestParam(&quot;query&quot;)</span> String query)</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.graphQL.execute(query).toSpecification(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.编写GraphQLProvider需要与SpringBoot整合，将GraphQL对象加载到Spring容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLProvider</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> GraphQL graphQL; </span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> HouseResourcesService houseResourcesService; </span><br><span class="line">  <span class="meta">@PostConstruct</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    File file = ResourceUtils.getFile(<span class="string">&quot;classpath:haoke.graphqls&quot;</span>); </span><br><span class="line">    GraphQLSchema graphQLSchema = buildSchema(file); </span><br><span class="line">    <span class="keyword">this</span>.graphQL = GraphQL.newGraphQL(graphQLSchema).build(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">    TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> SchemaParser().parse(file); </span><br><span class="line">    RuntimeWiring runtimeWiring = buildWiring(); </span><br><span class="line">    SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator(); </span><br><span class="line">    <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> RuntimeWiring <span class="title">buildWiring</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring() .type(<span class="string">&quot;HaokeQuery&quot;</span>, builder -&gt;  builder.dataFetcher(<span class="string">&quot;HouseResources&quot;</span>, environment -&gt; &#123; </span><br><span class="line">      Long id = environment.getArgument(<span class="string">&quot;id&quot;</span>); </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.houseResourcesService.queryById(id); </span><br><span class="line">    &#125; )).build(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GraphQL <span class="title">graphQL</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> graphQL; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以后每当增加查询时，都需要修改该方法，如果查询方法很多的话，那么这个方法将变得非常难以维护，所以需要</p><p>进改进。</p></blockquote><p>编写MyDataFetcher接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyDataFetcher</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">fieldName</span><span class="params">()</span></span>;<span class="comment">//查询名称</span></span><br><span class="line">  <span class="function">Object <span class="title">dataFetcher</span><span class="params">(DataFetchingEnvironment environment)</span></span>;<span class="comment">//具体实现查询的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写实现类HouseResourcesDataFetcher</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//加入到Spring容器 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseResourcesDataFetcher</span> <span class="keyword">implements</span> <span class="title">MyDataFetcher</span> </span>&#123; </span><br><span class="line">  <span class="meta">@Autowired</span> </span><br><span class="line">  <span class="keyword">private</span> HouseResourcesService houseResourcesService; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">fieldName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;HouseResources&quot;</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">dataFetcher</span><span class="params">(DataFetchingEnvironment environment)</span> </span>&#123; </span><br><span class="line">    Long id = environment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.houseResourcesService.queryById(id); <span class="comment">//实现了逻辑</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改GraphQLProvider逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLProvider</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> GraphQL graphQL; </span><br><span class="line">  <span class="meta">@Autowired</span> </span><br><span class="line">  <span class="keyword">private</span> List&lt;MyDataFetcher&gt; myDataFetchers; <span class="comment">//注入容器中所有的MyDataFetcher实现类 </span></span><br><span class="line">  <span class="meta">@PostConstruct</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; </span><br><span class="line">    File file = ResourceUtils.getFile(<span class="string">&quot;classpath:haoke.graphqls&quot;</span>); </span><br><span class="line">    GraphQLSchema graphQLSchema = buildSchema(file); </span><br><span class="line">    <span class="keyword">this</span>.graphQL = GraphQL.newGraphQL(graphQLSchema).build(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> GraphQLSchema <span class="title">buildSchema</span><span class="params">(File file)</span> </span>&#123; </span><br><span class="line">    TypeDefinitionRegistry typeRegistry = <span class="keyword">new</span> SchemaParser().parse(file); </span><br><span class="line">    RuntimeWiring runtimeWiring = buildWiring(); </span><br><span class="line">    SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator(); </span><br><span class="line">    <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> RuntimeWiring <span class="title">buildWiring</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring() .type(<span class="string">&quot;HaokeQuery&quot;</span>, builder -&gt; &#123; </span><br><span class="line">      <span class="keyword">for</span> (MyDataFetcher myDataFetcher : myDataFetchers) &#123; </span><br><span class="line">        builder.dataFetcher(myDataFetcher.fieldName(), environment -&gt; </span><br><span class="line">                            myDataFetcher.dataFetcher(environment));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> builder; </span><br><span class="line">    &#125;).build(); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> GraphQL <span class="title">graphQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> graphQL; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面如果要加业务逻辑之类的直接实现MyDataFetcher接口，把实现逻辑方法写一下，在Provider中通过myDataFetchers注入容器中所有的实现类，然后在方法中循环实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.导入依赖&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GraphQL学习之java实现</title>
    <link href="http://example.com/2020/10/30/GraphQL%E5%AD%A6%E4%B9%A0%E4%B9%8Bjava%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2020/10/30/GraphQL%E5%AD%A6%E4%B9%A0%E4%B9%8Bjava%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-10-30T00:33:21.000Z</published>
    <updated>2020-10-30T01:40:11.312Z</updated>
    
    <content type="html"><![CDATA[<p>1.导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.graphql-java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>graphql-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>说明：graphql-java包并没有发布到maven中央仓库，需要配置第三方仓库才能使用。</p><p>在setting.xml文件里进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>bintray<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>bintray<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dl.bintray.com/andimarek/graphql-java<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>bintray<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dl.bintray.com/andimarek/graphql-java<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">releases</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">releases</span>&gt;</span> <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span> ………………………………………… </span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span> ……………… </span><br><span class="line">  <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>bintray<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>创建user对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.graphql.vo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id; </span><br><span class="line">  <span class="keyword">private</span> String name; </span><br><span class="line">  <span class="keyword">private</span> Integer age; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Long id, String name, Integer age)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.id = id; </span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> id; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.id = id; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = name; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> age; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.age = age; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写查询User对象实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#对应的User定义如下 </span><br><span class="line">schema &#123; #定义查询</span><br><span class="line">query: UserQuery </span><br><span class="line">&#125;</span><br><span class="line">type UserQuery &#123; #定义查询的类型 </span><br><span class="line">user : User #指定对象以及参数类型 </span><br><span class="line">&#125;</span><br><span class="line">type User &#123; #定义对象 </span><br><span class="line">id:Long! # !表示该属性是非空项 </span><br><span class="line">name:String</span><br><span class="line">age:Int </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.graphql.demo; </span><br><span class="line"><span class="keyword">import</span> cn.itcast.graphql.vo.User; </span><br><span class="line"><span class="keyword">import</span> graphql.ExecutionResult; </span><br><span class="line"><span class="keyword">import</span> graphql.GraphQL; </span><br><span class="line"><span class="keyword">import</span> graphql.schema.GraphQLFieldDefinition; </span><br><span class="line"><span class="keyword">import</span> graphql.schema.GraphQLObjectType; </span><br><span class="line"><span class="keyword">import</span> graphql.schema.GraphQLSchema; </span><br><span class="line"><span class="keyword">import</span> graphql.schema.StaticDataFetcher; </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> graphql.Scalars.*; </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> graphql.schema.GraphQLFieldDefinition.newFieldDefinition; </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> graphql.schema.GraphQLObjectType.newObject;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLDemo</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义Schema </span></span><br><span class="line"><span class="comment">  * &lt;p&gt; </span></span><br><span class="line"><span class="comment">  * schema &#123; #定义查询 </span></span><br><span class="line"><span class="comment">  * query: UserQuery </span></span><br><span class="line"><span class="comment">  * &#125; </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GraphQLSchema <span class="title">createGraphqlSchema</span><span class="params">(GraphQLFieldDefinition userDefinition)</span> </span>&#123;   </span><br><span class="line">    GraphQLObjectType userQuery = newObject().name(<span class="string">&quot;userQuery&quot;</span>) .field(userDefinition).build(); </span><br><span class="line">    <span class="keyword">return</span> GraphQLSchema.newSchema().query(userQuery).build(); </span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义查询的类型 </span></span><br><span class="line"><span class="comment">  * &lt;p&gt; </span></span><br><span class="line"><span class="comment">  * type UserQuery &#123; #定义查询的类型 </span></span><br><span class="line"><span class="comment">  * user : User #指定对象 </span></span><br><span class="line"><span class="comment">  * &#125; </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GraphQLFieldDefinition <span class="title">createUserDefinition</span><span class="params">(GraphQLObjectType userType)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newFieldDefinition()</span><br><span class="line">        .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">        .type(userType)</span><br><span class="line">        <span class="comment">//静态数据 （和下面设置参数二选一） </span></span><br><span class="line">        .dataFetcher(<span class="keyword">new</span> StaticDataFetcher(<span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)))</span><br><span class="line">        <span class="comment">// 设置参数 （和上面静态数据二选一）</span></span><br><span class="line">        .argument(newArgument().name(<span class="string">&quot;id&quot;</span>).type(GraphQLLong).build()) </span><br><span class="line">        .dataFetcher(environment -&gt; &#123;  <span class="comment">// environment是从前端传来的数据</span></span><br><span class="line">          Long id = environment.getArgument(<span class="string">&quot;id&quot;</span>); </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;张三_&quot;</span>+id, <span class="number">20</span> + id.intValue()); &#125;)</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义User对象类型 </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * type User &#123; #定义对象 </span></span><br><span class="line"><span class="comment">  * id:Long! # !表示该属性是非空项 </span></span><br><span class="line"><span class="comment">  * name:String </span></span><br><span class="line"><span class="comment">  * age:Int </span></span><br><span class="line"><span class="comment">  * &#125; </span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GraphQLObjectType <span class="title">createUserObjectType</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newObject()</span><br><span class="line">        .name(<span class="string">&quot;User&quot;</span>)</span><br><span class="line">        .field(newFieldDefinition().name(<span class="string">&quot;id&quot;</span>).type(GraphQLLong))</span><br><span class="line">        .field(newFieldDefinition().name(<span class="string">&quot;name&quot;</span>).type(GraphQLString))</span><br><span class="line">        .field(newFieldDefinition().name(<span class="string">&quot;age&quot;</span>).type(GraphQLInt))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//主函数测试</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到userType放入GraphQLFieldDefinition中</span></span><br><span class="line">    GraphQLObjectType userObjectType = createUserObjectType();</span><br><span class="line">    <span class="comment">//得到userDefinition放入GraphQLSchema中</span></span><br><span class="line">    GraphQLFieldDefinition userDefinition = createUserDefinition(userObjectType);</span><br><span class="line">    <span class="comment">//新建GraphQL对象</span></span><br><span class="line">    GraphQL graphQL = GraphQL.newGraphQL(createGraphqlSchema(userDefinition)).build();</span><br><span class="line">    <span class="comment">//查询条件</span></span><br><span class="line">    String query = <span class="string">&quot;&#123;User&#123;id,name&#125;&#125;&quot;</span>; <span class="comment">//&#123;User(id:1)&#123;id,name&#125;&#125; 设置查询参数的查询条件</span></span><br><span class="line">      <span class="comment">//执行</span></span><br><span class="line">      ExecutionResult executionResult = graphQL.execute(query);</span><br><span class="line">     <span class="comment">//打印数据</span></span><br><span class="line">    System.out.println...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用SDL构建schema</p><blockquote><p>推荐使用：SDL方法</p></blockquote><p>创建user.graphqls文件</p><p>在resources目录下创建user.graphqls文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema &#123; </span><br><span class="line">query: UserQuery</span><br><span class="line">&#125;</span><br><span class="line">type UserQuery &#123; </span><br><span class="line">user(id:Long) : User </span><br><span class="line">&#125;</span><br><span class="line">type User &#123;</span><br><span class="line">    id:Long! </span><br><span class="line">    name:String</span><br><span class="line">    age:Int </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装graphql插件</p><p>实现：因为在配置文件中，所以一定要读取配置文件得到相应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphQLSDLDemo</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 读取文件内容 </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fileName </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFileToString</span><span class="params">(String fileName)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> IOUtils.toString(GraphQLSDLDemo.class.getClassLoader().getResourceAsStream(fileName ), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//定义Schema</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> GraphQLSchema <span class="title">createGraphqlSchema</span><span class="params">(TypeDefinitionRegistry typeRegistry, RuntimeWiring wiring)</span> </span>&#123;</span><br><span class="line">  SchemaGenerator schemaGenerator = <span class="keyword">new</span> SchemaGenerator();</span><br><span class="line">        <span class="keyword">return</span> schemaGenerator.makeExecutableSchema(typeRegistry, wiring);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义类型的注册器</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TypeDefinitionRegistry <span class="title">createTypeDefinitionRegistry</span><span class="params">(String fileContent)</span></span>&#123;</span><br><span class="line">    SchemaParser schemaParser = <span class="keyword">new</span> SchemaParser();</span><br><span class="line">      <span class="keyword">return</span> schemaParser.parse(fileContent);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//解决数据查询问题</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RuntimeWiring <span class="title">createRuntimeWiring</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RuntimeWiring.newRuntimeWiring()</span><br><span class="line">          .type(<span class="string">&quot;UserQuery&quot;</span>, typeWiring -&gt; typeWiring</span><br><span class="line">                .dataFetcher(<span class="string">&quot;user&quot;</span>, environment -&gt; &#123;</span><br><span class="line">                  Long id = environment.getArgument(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">&quot;张三_&quot;</span>+id, <span class="number">20</span> + id.intValue());</span><br><span class="line">                  &#125;)</span><br><span class="line">                ).build();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String fileName = <span class="string">&quot;user.graphqls&quot;</span>;</span><br><span class="line">      TypeDefinitionRegistry registry=createTypeDefinitionRegistry(readFileToString(fileName));</span><br><span class="line">      RuntimeWiring runtimeWiring = createRuntimeWiring();</span><br><span class="line">      <span class="comment">//新建GraphQl对象--createGraphqlSchema实现方式与第一次不同，两个参数</span></span><br><span class="line">      GraphQL graphQL = GraphQL.newGraphQL(createGraphqlSchema(registry, runtimeWiring)).build();</span><br><span class="line">      String query = <span class="string">&quot;&#123;user(id:1)&#123;id,name,age&#125;&#125;&quot;</span>;</span><br><span class="line">      ExecutionResult executionResult = graphQL.execute(query);</span><br><span class="line">      System.out.println...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>两种方式的数据都是静态数据，以后要自己实现查询语句。</p><p>第一种用java一步一步的写graphql语句一样，先定义查询，再定义查询类型，再定义对象类型；</p><p>第二种写配置文件，读取之后放入定义类型的注册器中，createGraphqlSchema还需要一个参数就是runtimeWiring解决数据查询问题</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.导入依赖&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GraphQL入门</title>
    <link href="http://example.com/2020/10/30/GraphQL%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2020/10/30/GraphQL%E5%85%A5%E9%97%A8/</id>
    <published>2020-10-29T23:57:42.000Z</published>
    <updated>2020-10-30T00:29:09.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、GraphQL介绍"><a href="#一、GraphQL介绍" class="headerlink" title="一、GraphQL介绍"></a>一、GraphQL介绍</h3><p>GraphQL 是由 Facebook 创造的用于描述复杂数据模型的一种查询语言。这里查询语言所指的并不是常规意义上</p><p>的类似 sql 语句的查询语言，而是一种用于前后端数据查询方式的规范。</p><h3 id="二、GraphQL比Restful的优点"><a href="#二、GraphQL比Restful的优点" class="headerlink" title="二、GraphQL比Restful的优点"></a>二、GraphQL比Restful的优点</h3><p>解决Restful接口的资源浪费问题，因为当我们想要查询某请求的id和name字段，但是他还有很多字段我们不需要，如果全部拿到而只响应id和name那就是一种资源浪费。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#请求 GET http://127.0.0.1/user/1001</span><br><span class="line">#响应： </span><br><span class="line">&#123; </span><br><span class="line">id : 1001, </span><br><span class="line">name : &quot;张三&quot;, </span><br><span class="line">age : 20, //不需要</span><br><span class="line">address : &quot;北京市&quot;, //不需要</span><br><span class="line">……  //不需要</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Restful接口的请求与响应</p></blockquote><p>还有一种问题是Retful的一次请求不能满足需求，需要有多次请求才能完成，而GraphQL可以一次请求满足</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#查询用户信息 GET http://127.0.0.1/user/1001 </span><br><span class="line">#响应： </span><br><span class="line">&#123; </span><br><span class="line">id : 1001, </span><br><span class="line">name : &quot;张三&quot;, </span><br><span class="line">age : 20, </span><br><span class="line">address : &quot;北京市&quot;,</span><br><span class="line">  …… </span><br><span class="line">&#125;</span><br><span class="line">#查询用户的身份证信息 GET http://127.0.0.1/card/8888 </span><br><span class="line">#响应： </span><br><span class="line">&#123; </span><br><span class="line">id : 8888, </span><br><span class="line">name : &quot;张三&quot;, </span><br><span class="line">cardNumber : &quot;999999999999999&quot;, </span><br><span class="line">address : &quot;北京市&quot;, </span><br><span class="line">…… </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Restful接口的多次请求满足响应需求</p></blockquote><h3 id="三、进一步了解GraphQL"><a href="#三、进一步了解GraphQL" class="headerlink" title="三、进一步了解GraphQL"></a>三、进一步了解GraphQL</h3><p>1.按需索取，避免浪费</p><p>2.一次查询多个数据</p><p>3.API演进无需划分版本</p><h3 id="四、查询规范"><a href="#四、查询规范" class="headerlink" title="四、查询规范"></a>四、查询规范</h3><p>1.字段：查询和其结果拥有几乎一样的结构</p><p>2.参数：语法格式：（参数名：参数值）</p><p>3.别名：一次查询多个相同对象，但是值不同，要起别名 </p><p>别名1：对象(){}</p><p>别名2：对象(){}</p><p>4.片段：查询对的属相如果相同，可以采用片段的方式进行简化定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">别名1：对象()&#123;</span><br><span class="line">...片段名</span><br><span class="line">&#125;</span><br><span class="line">别名2：对象()&#123;</span><br><span class="line">...片段名</span><br><span class="line">&#125;</span><br><span class="line">fragment 片段名 on Character&#123;</span><br><span class="line">属性</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、GraphQL的Schema和类型规范"><a href="#五、GraphQL的Schema和类型规范" class="headerlink" title="五、GraphQL的Schema和类型规范"></a>五、GraphQL的Schema和类型规范</h3><p>Schema定义结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema &#123; #定义查询 </span><br><span class="line">query: UserQuery </span><br><span class="line">&#125;</span><br><span class="line">type UserQuery &#123; #定义查询的类型 </span><br><span class="line">user(id:ID) : User #指定对象以及参数类型 </span><br><span class="line">&#125;</span><br><span class="line">type User &#123; #定义对象 </span><br><span class="line">id:ID! # !表示该属性是非空项 </span><br><span class="line">name:String </span><br><span class="line">age:Int </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标量类型：</p><ul><li><p>Int ：有符号 32 位整数。</p></li><li><p>Float ：有符号双精度浮点值。</p></li><li><p>String ：UTF‐8 字符序列。</p></li><li><p>Boolean ： true 或者 false 。 </p></li><li><p>ID ：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。</p></li></ul><p>接口：跟许多类型系统一样，GraphQL 支持接口。一个接口是一个抽象类型，它包含某些字段，而对象类型必须包含这</p><p>些字段，才能算实现了这个接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、GraphQL介绍&quot;&gt;&lt;a href=&quot;#一、GraphQL介绍&quot; class=&quot;headerlink&quot; title=&quot;一、GraphQL介绍&quot;&gt;&lt;/a&gt;一、GraphQL介绍&lt;/h3&gt;&lt;p&gt;GraphQL 是由 Facebook 创造的用于描述复杂数据模型的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM基本参数命令</title>
    <link href="http://example.com/2020/10/28/JVM%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2020/10/28/JVM%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-28T02:47:25.000Z</published>
    <updated>2020-10-28T03:07:50.904Z</updated>
    
    <content type="html"><![CDATA[<p>JVM参数类型分三种：1.标准参数、2.-X参数、3.-XX参数（使用率高）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">标准参数常用命令：</span><br><span class="line">java -version 查看版本</span><br><span class="line">java -showversion 查看版本并退出</span><br><span class="line">java -D&lt;名称&gt;&#x3D;&lt;值&gt; 设置系统属性</span><br><span class="line">java -help 输出帮助消息</span><br><span class="line">java -server 选择server VM 默认就是server</span><br><span class="line">java -client 选择client VM</span><br></pre></td></tr></table></figure><p> -server与-client区别：ServerVM初始堆空间大，默认使用并行垃圾回收器，启动慢运行快，ClientVM初始堆空间小，使用串行垃圾回收器，启动更快，运行更慢。还有一点就是现在64位机器只支持server不支持client了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-X参数常用命令：</span><br><span class="line">主要是三种模式</span><br><span class="line">-Xint：解释模式</span><br><span class="line">-Xcomp：编译模式</span><br><span class="line">-Xmixed：混合模式</span><br></pre></td></tr></table></figure><p>-Xint模式会强制JVM执行所有字节码，运行速度低，-Xcomp使用时，会把所有代码编译成本地代码，-Xmixed是混合模式，是默认的，由JVM自己决定。-Xint是编译比较快而运行是比较慢的<br>-Xcomp是编译比较慢但是运行是比较快的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX参数常用命令：</span><br><span class="line">两种方式，boolean类型与非boolean类型</span><br><span class="line">boolean：-XX：[+-]&lt;名称&gt; 表示禁止或启动某命令</span><br><span class="line">非boolean：-XX：NewRatio&#x3D;1 表示新生代与老年代的比值</span><br><span class="line">-Xms：JVM初始堆内存，等价于-XX:InitialHeapSize</span><br><span class="line">-XmX：JVm最大堆内存，等价于-XX:MaxHeapSize，</span><br><span class="line">-XX:+PrintFlagsFinal  查看jvm运行参数</span><br></pre></td></tr></table></figure><p>、运行-XX：+PrintFlagsFinal查看运行参数时，出现=与:=两种形式，其中=表示原始值，而:=表示修改过的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jps -l 查看进程id</span><br><span class="line">jinfo -flags &lt;进程id&gt; 查看正在运行的jvm所有参数</span><br><span class="line">jinfo -flags &lt;参数名&gt; &lt;进程id&gt; 查看某个特定参数</span><br><span class="line">jstat 查看堆内存使用情况</span><br><span class="line">jstat -class &lt;pid&gt; 查看class加载统计</span><br><span class="line">jstat -complier &lt;pid&gt; 查看编译统计</span><br><span class="line">jstat -gc &lt;pid&gt; 查看垃圾回收统计</span><br><span class="line">jmap 对堆内存进行统计分析</span><br><span class="line">jmap -heap &lt;pid&gt; 查看内存使用情况</span><br><span class="line">jmap -histo &lt;pid&gt; | more 查看内存中所有对象数量及大小</span><br><span class="line">jmap -histo:live &lt;pid&gt; | more 查看内存中活跃对象的数量及大小</span><br><span class="line">jmap -dump:format&#x3D;b,file&#x3D;&#x2F;temp&#x2F;dumpdat &lt;pid&gt; 将内存使用情况dump到文件中</span><br><span class="line">jhat -port &lt;port&gt; &lt;file&gt; 用jhat将二进制dump文件打开并开启一个端口供访问分析</span><br></pre></td></tr></table></figure><p>两个可视化工具，MAT，VisualVM。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JVM参数类型分三种：1.标准参数、2.-X参数、3.-XX参数（使用率高）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收和垃圾收集器</title>
    <link href="http://example.com/2020/10/28/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>http://example.com/2020/10/28/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2020-10-28T02:47:10.000Z</published>
    <updated>2020-10-28T03:07:26.962Z</updated>
    
    <content type="html"><![CDATA[<p>java与C语音不同，C语音需要手动垃圾回收，而java只需要关心内存申请，不需要关心垃圾回收。</p><h4 id="算法：：垃圾回收算法：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。"><a href="#算法：：垃圾回收算法：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。" class="headerlink" title="算法：：垃圾回收算法：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。"></a>算法：：垃圾回收算法：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。</h4><p>引用计数法：每个对象都有一个计数器，每当对象被引用时就+1，不被引用就-1，最后都不引用的时候，计数器为0，这时如果进行垃圾回收，此对象会被回收掉。优点：实时性好，不用等内存满了再清理，计数器为0可以直接回收掉；缺点：更新数据会有一点时间开销，浪费cpu资源，最大的问题是无法解决循环引用问题。</p><p>标记清除法：从根节点开始标记引用的对象，未被标记的就回收掉，即使两个对象循环引用但是从根节点标记引用的对象没有这两个，所以会被回收掉。解决了循环引用无法回收的问题，这是优点，缺点是效率低下，每次都要遍历所有对象，对其进行标记和清除，并且清理后的内存碎片化严重</p><p>标记压缩法：标记清除法的改进，标记相同，清除时，先将存活的对象压缩到内存一端，然后清理掉其他对象，优点是解决了碎片化问题，但是多了一步移动对象的操作，效率也会低下。</p><p>复制算法：复制算法的核心就是，将原有的内存空间一分为二，每次只用其中的一块，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内<br>存的角色，完成垃圾的回收。值得一提的是jvm中的年轻代两个survivor区就是用的这样的算法。优点是垃圾对象多时，效率较高，内存无碎片化。缺点是垃圾对象少时，不适用，比如老年代，再就是一次只能用一半的内存空间内存使用率低。</p><p>分代算法：根据回收对象的特点进行选择，在jvm中，年轻代适合使用复<br>制算法，老年代适合使用标记清除或标记压缩算法。</p><h4 id="收集器：包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器。"><a href="#收集器：包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器。" class="headerlink" title="收集器：包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器。"></a>收集器：包括：串行垃圾收集器、并行垃圾收集器、CMS（并发）垃圾收集器、G1垃圾收集器。</h4><p>串行垃圾收集器：是指使用单线程进行垃圾回收，工作时只有一个线程，其他程序都要暂停，这种现象称为STW（Stop-The-World），对于交互性较强的应用而言，这种垃圾收集器是不能够接受的。一般在Javaweb应用中是不会采用该收集器的。因为交互性的应用暂停服务会影响使用效果。</p><p>并行垃圾收集器：将单线程改为了多线程进行垃圾回收，这样可以缩短垃圾回收的时间。但是还是要出现STW现象</p><p>①ParNew垃圾收集器：只是单纯的把单线程改为多线程。</p><p>②ParallelGC垃圾收集器：新增了两个和系统吞吐量相关的参数，使得其使用起来更加的灵活和高效。</p><p>CMS垃圾收集器：CMS以获取最小停顿时间为目的，这样就可以用在交互性的应用上。因为要获取最小停顿时间，所以对执行过程进行细化，比较复杂，下面是运行过程：</p><ol><li>初始化标记(CMS-initial-mark) ,标记root，会导致stw；</li><li>并发标记(CMS-concurrent-mark)，与用户线程同时运行；</li><li>预清理（CMS-concurrent-preclean），与用户线程同时运行；</li><li>重新标记(CMS-remark) ，会导致stw；</li><li>并发清除(CMS-concurrent-sweep)，与用户线程同时运行；</li><li>调整堆大小，设置CMS在清理之后进行内存压缩，目的是清理内存中的碎片；</li><li>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)，与用户线程同时运行；</li></ol><p>G1垃圾收集器：G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：第一步，开启G1垃圾收集器第二步，设置堆的最大内存第三步，设置最大的停顿时间。</p><p>G1中提供了三种模式垃圾回收模式，Young GC、Mixed GC 和 Full GC，在不同的条件<br>下被触发。</p><p>G1垃圾收集器的设计思想：与其他收集器相比，G1的最大区别是它摒弃了年轻代、老年代的物理划分，采用将堆内存分为若干个区域，这些区域包含了逻辑上的老年区，年轻区，还有一种特殊区域Humongous区，它主要装的是巨型对象。</p><p>在G1划分的区域中，年轻代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象<br>拷贝到老年代或者Survivor空间，G1收集器通过将对象从一个区域复制到另外一个区<br>域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了。</p><p>Young GC：主要对Eden区进行GC，在Eden区快耗尽时触发，存活数据移动到Survivor区，如果Survivor不够，则有部分移到年老代。Eden区数据为空时，停止GC。</p><p>Remembered Set（已记忆集合）其作用是跟踪指向某个堆内的对象引用。为找到年轻代的根对象采用这种方法，不然将年老代遍历一遍会很浪费时间。</p><p>Mixed GC：回收整个年轻代和部分年老代。触发是由参数 -XX:InitiatingHeapOccupancyPercent=n 决定。默认：45%，该参数的意思是：当老年代大小占整个堆大小百分比达到该阀值时触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">‐XX:+PrintGC 输出GC日志</span><br><span class="line">‐XX:+PrintGCDetails 输出GC的详细日志</span><br><span class="line">‐XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</span><br><span class="line">‐XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013‐05‐</span><br><span class="line">04T21:53:59.234+0800）</span><br><span class="line">‐XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</span><br><span class="line">‐Xloggc:..&#x2F;logs&#x2F;gc.log 日志文件的输出路径</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">‐XX:+UseG1GC ‐XX:MaxGCPauseMillis&#x3D;100 ‐Xmx256m ‐XX:+PrintGCDetails ‐</span><br><span class="line">XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐XX:+PrintHeapAtGC ‐</span><br><span class="line">Xloggc:F:&#x2F;&#x2F;test&#x2F;&#x2F;gc.log</span><br></pre></td></tr></table></figure><p>最后介绍一个GC日志查看的网址：GC Easy是一款在线的可视化工具，易用、功能强大，网站：<a href="http://gceasy.io/">http://gceasy.io/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java与C语音不同，C语音需要手动垃圾回收，而java只需要关心内存申请，不需要关心垃圾回收。&lt;/p&gt;
&lt;h4 id=&quot;算法：：垃圾回收算法：引用计数法、标记清除法、标记压缩法、复制算法、分代算法等。&quot;&gt;&lt;a href=&quot;#算法：：垃圾回收算法：引用计数法、标记清除法、标</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Tomcat8优化入门</title>
    <link href="http://example.com/2020/10/28/Tomcat8%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2020/10/28/Tomcat8%E4%BC%98%E5%8C%96%E5%85%A5%E9%97%A8/</id>
    <published>2020-10-28T02:46:53.000Z</published>
    <updated>2020-10-28T03:11:02.324Z</updated>
    
    <content type="html"><![CDATA[<p>1.禁用AJP服务，默认开启占用8009端口</p><p>2.设置线程池，maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000；minSpareThreads：Tomcat 初始化时创建的线程数，默认设置 25；prestartminSpareThreads： 在 Tomcat 初始化的时候就初始化 minSpareThreads 的<br>参数值，如果不等于 true，minSpareThreads 的值就没啥效果了</p><p>3.nio2运行模式，protocol=”org.apache.coyote.http11.Http11Nio2Protocol”</p><p>4.设置jvm垃圾回收器</p><p>前三个是对tomcat8自身优化，后面是对jvm参数调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.禁用AJP服务，默认开启占用8009端口&lt;/p&gt;
&lt;p&gt;2.设置线程池，maxThreads：最大并发数，默认设置 200，一般建议在 500 ~ 1000；minSpareThreads：Tomcat 初始化时创建的线程数，默认设置 25；prestartminSpa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于向数据库添加信息时未设置id报错</title>
    <link href="http://example.com/2020/10/28/%E5%85%B3%E4%BA%8E%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF%E6%97%B6%E6%9C%AA%E8%AE%BE%E7%BD%AEid%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2020/10/28/%E5%85%B3%E4%BA%8E%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF%E6%97%B6%E6%9C%AA%E8%AE%BE%E7%BD%AEid%E6%8A%A5%E9%94%99/</id>
    <published>2020-10-28T02:46:00.000Z</published>
    <updated>2020-10-28T03:13:50.130Z</updated>
    
    <content type="html"><![CDATA[<p>错误信息：ids for this class must be manually assigned before calling save(): sample.db.Completedsample</p><p>原因分析：从字面上理解的意思是，在save之前，必须手动指定id，其中id的；</p><p>解决办法：将主键设为自增，原先需要主键表示的数据，重新设置一个键。此时主键id的 ；之前主键没有设为自增，将id的generator的class设为increment也是同样的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;错误信息：ids for this class must be manually assigned before calling save(): sample.db.Completedsample&lt;/p&gt;
&lt;p&gt;原因分析：从字面上理解的意思是，在save之前，必须手动指定i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记录一下一个小bug 关于Map集合的</title>
    <link href="http://example.com/2020/10/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%B0%8Fbug-%E5%85%B3%E4%BA%8EMap%E9%9B%86%E5%90%88%E7%9A%84/"/>
    <id>http://example.com/2020/10/28/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%B0%8Fbug-%E5%85%B3%E4%BA%8EMap%E9%9B%86%E5%90%88%E7%9A%84/</id>
    <published>2020-10-28T02:44:55.000Z</published>
    <updated>2020-10-28T03:12:51.456Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@data</span><span class="comment">//lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileResult</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; map;</span><br><span class="line"><span class="comment">//构造方法...</span></span><br><span class="line">String menus = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.map.put(<span class="string">&quot;menus&quot;</span>,menus);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------</span></span><br><span class="line"><span class="meta">@data</span><span class="comment">//lombok</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileResult</span></span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//构造方法...</span></span><br><span class="line">String menus = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.map.put(<span class="string">&quot;menus&quot;</span>,menus);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种写法，第一种会报错；因为map没有指向Map对象，报空指针异常；而第二种就在定义变量时赋值再调用方法时不会报异常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于拦截器方法抛异常问题</title>
    <link href="http://example.com/2020/10/28/%E5%85%B3%E4%BA%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E6%96%B9%E6%B3%95%E6%8A%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/10/28/%E5%85%B3%E4%BA%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E6%96%B9%E6%B3%95%E6%8A%9B%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-28T02:44:22.000Z</published>
    <updated>2020-10-28T03:12:02.082Z</updated>
    
    <content type="html"><![CDATA[<p>前些日子写了个SpringMVC的拦截器方法preHandle最后判断否的时候抛出自定义异常，但是前端没有接收到，并报错自定义异常为null CommonException：null 然后查了一下，应该写一个异常处理类加@ControllerAdvice注解并扫描拦截器的包，方法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler(value = Exception.class)</span><span class="comment">//异常处理注解</span></span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//响应对象转化为json</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">error</span><span class="params">(HttpServletRequest request, HttpServletResponse response,Exception e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span>(e.getClass() == CommonException.class) &#123;<span class="comment">//接收到异常并判断是否为CommonException</span></span><br><span class="line">            <span class="comment">//类型转型</span></span><br><span class="line">            CommonException ce = (CommonException) e;</span><br><span class="line">            Result result = <span class="keyword">new</span> Result(ce.getResultCode());<span class="comment">//返回result</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Result result = <span class="keyword">new</span> Result(ResultCode.SERVER_ERROR);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前些日子写了个SpringMVC的拦截器方法preHandle最后判断否的时候抛出自定义异常，但是前端没有接收到，并报错自定义异常为null CommonException：null 然后查了一下，应该写一个异常处理类加@ControllerAdvice注解并扫描拦截器的包</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shrio安全框架入门</title>
    <link href="http://example.com/2020/10/28/Shrio%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2020/10/28/Shrio%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8/</id>
    <published>2020-10-28T02:44:05.000Z</published>
    <updated>2020-10-28T03:10:32.924Z</updated>
    
    <content type="html"><![CDATA[<p>作为安全框架shiro更加便捷简单，相比与Spring Security来说。</p><p>shiro主要使用的几个内部结构：</p><p>Subject:主体，可以看到主体可以是任何可以与应用交互的“用户”;</p><p>SecurityManager:相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher;是Shiro的心 脏;所有具体的交互都通过SecurityManager进行控制;它管理着所有Subject、且负责进行认证和授权、及会 话、缓存的管理。</p><p>Authenticator:认证器，负责主体认证的。</p><p>Authrizer:授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作。</p><p>Realm:可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的;可以是JDBC实现，也可 以是LDAP实现，或者内存实现等等;由用户提供;注意:Shiro不知道你的用户/权限存储在哪及以何种格式存储; 所以我们一般在应用中都需要实现自己的Realm;</p><p>应用程序使用shiro过程</p><p>应用代码通过Subject来进行认证和授权，Subject委托给SecurityManage ,Realm被注入到SecurityManage中，Realm相当于从数据库获取安全数据。</p><p>﻿</p><p>1基于ini运行模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  #模拟从数据库查询的用户 #数据格式 用户名=密码 zhangsan=123456 lisi=654321 //配置文件</span><br><span class="line"></span><br><span class="line"><span class="comment">//认证</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123; </span><br><span class="line"><span class="comment">//1.加载ini配置文件创建</span></span><br><span class="line">SecurityManager Factory&lt;SecurityManager&gt; factory = <span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">&quot;classpath:shiro.ini&quot;</span>); </span><br><span class="line"><span class="comment">//2.获取securityManager</span></span><br><span class="line">SecurityManager securityManager = factory.getInstance(); </span><br><span class="line"><span class="comment">//3.将securityManager绑定到当前运行环境 </span></span><br><span class="line">SecurityUtils.setSecurityManager(securityManager); </span><br><span class="line"><span class="comment">//4.创建主体(此时的主体还为经过认证)</span></span><br><span class="line">Subject subject = SecurityUtils.getSubject();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 模拟登录，和传统等不同的是需要使用主体进行登录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//5.构造主体登录的凭证(即用户名/密码)</span></span><br><span class="line"><span class="comment">//第一个参数:登录用户名，第二个参数:登录密码</span></span><br><span class="line">UsernamePasswordToken upToken = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;123456&quot;</span>); </span><br><span class="line"><span class="comment">//6.主体登录</span></span><br><span class="line">subject.login(upToken);</span><br><span class="line"><span class="comment">//7.验证是否登录成功</span></span><br><span class="line">System.out.println(<span class="string">&quot;用户登录成功=&quot;</span>+subject.isAuthenticated());</span><br><span class="line"><span class="comment">//8.登录成功获取数据</span></span><br><span class="line"><span class="comment">//getPrincipal 获取登录成功的安全数据</span></span><br><span class="line">System.out.println(subject.getPrincipal());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//授权</span></span><br><span class="line"><span class="comment">//配置文件 [users] #数据格式 用户名=密码,角色1,角色2.. zhangsan=123456,role1,role2</span></span><br><span class="line">          [roles] #数据格式 角色名=权限1，权限2 role1=user:save,user:update</span><br><span class="line"><span class="comment">//7.用户认证成功之后才可以完成授权工作</span></span><br><span class="line"><span class="keyword">boolean</span> hasPerm = subject.isPermitted(<span class="string">&quot;user:save&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;用户是否具有save权限=&quot;</span>+hasPerm);</span><br></pre></td></tr></table></figure><p>自定义realm 需要继承AuthorizingRealm父类 重写父类中的两个方法，</p><p>doGetAuthorizationInfo :授权   从principals参数变量中获取已认证用户的信息，然后查询根据得到的id或者用户查询权限</p><p> doGetAuthenticationInfo :认证  认证的主要目的，比较用户输入的用户名密码是否和数据库中的一致，首先要把传入的变量强转为UsernamePasswordToken以获取用户名和密码</p><p>认证流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Subject的login方法登录</span><br><span class="line">2.所有的Subject都委托于Security Manager管理</span><br><span class="line">3.Security Manager委托给Authenticator认证 它才是真正的身份验证，shiro API的核心身份认证入口，可以自定义实现</span><br><span class="line">4.Authenticator委托给AuthenticationStrategy进行Realm身份验证</span><br><span class="line">5.把token传入Realm中，获取身份验证信息</span><br></pre></td></tr></table></figure><p>授权流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 首先调用Subject.isPermitted&#x2F;hasRole接口，其会委托给SecurityManager，而SecurityManager接着会委托 给Authorizer;</span><br><span class="line">2. Authorizer是真正的授权者，如果我们调用如isPermitted(“user:view”)，其首先会通过PermissionResolver 把字符串转换成相应的Permission实例;</span><br><span class="line">3. 在进行授权之前，其会调用相应的Realm获取Subject相应的角色&#x2F;权限用于匹配传入的角色&#x2F;权限;</span><br><span class="line">4. Authorizer会判断Realm的角色&#x2F;权限是否和传入的匹配，如果有多个Realm，会委托给ModularRealmAuthorizer进行循环判断，如果匹配如isPermitted&#x2F;hasRole会返回true，否则返回false表示 授权失败。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为安全框架shiro更加便捷简单，相比与Spring Security来说。&lt;/p&gt;
&lt;p&gt;shiro主要使用的几个内部结构：&lt;/p&gt;
&lt;p&gt;Subject:主体，可以看到主体可以是任何可以与应用交互的“用户”;&lt;/p&gt;
&lt;p&gt;SecurityManager:相当于Spr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shiro与SpringBoot整合</title>
    <link href="http://example.com/2020/10/28/Shiro%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88/"/>
    <id>http://example.com/2020/10/28/Shiro%E4%B8%8ESpringBoot%E6%95%B4%E5%90%88/</id>
    <published>2020-10-28T02:43:54.000Z</published>
    <updated>2020-10-28T03:05:19.967Z</updated>
    
    <content type="html"><![CDATA[<ul><li>导入依赖</li><li>修改登录方法</li><li>自定义Realm</li><li>Shiro配置</li><li>Shiro过滤器</li><li>授权<ul><li>1基于配置授权</li><li>2基于注解授权</li></ul></li></ul><p>导入依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改登录方法：shiro需要采集到用户登录数据使用subject的login方法进入realm完成认证工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping(value=&quot;/login&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username,String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Subject subject = SecurityUtils.getSubject(); </span><br><span class="line">        UsernamePasswordToken uptoken = <span class="keyword">new</span> UsernamePasswordToken(username,password); </span><br><span class="line">        subject.login(uptoken);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;用户名或密码错误&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义Realm：Shiro从Realm获取安全数据(如用户、角色、权限)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">&quot;customRealm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造授权方法 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取认证的用户数据</span></span><br><span class="line">        User user = (User)principalCollection.getPrimaryPrincipal(); </span><br><span class="line">        <span class="comment">//2.构造认证数据</span></span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo(); Set&lt;Role&gt; roles = user.getRoles();</span><br><span class="line">        <span class="keyword">for</span> (Role role : roles) &#123;</span><br><span class="line">            <span class="comment">//添加角色信息</span></span><br><span class="line">            info.addRole(role.getName());</span><br><span class="line">            <span class="keyword">for</span> (Permission permission:role.getPermissions()) &#123;</span><br><span class="line">                <span class="comment">//添加权限信息</span></span><br><span class="line">                info.addStringPermission(permission.getCode()); </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 认证方法 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取登录的upToken</span></span><br><span class="line">        UsernamePasswordToken upToken = (UsernamePasswordToken)authenticationToken; </span><br><span class="line">        <span class="comment">//2.获取输入的用户名密码</span></span><br><span class="line">        String username = upToken.getUsername();</span><br><span class="line">        String password = <span class="keyword">new</span> String(upToken.getPassword());</span><br><span class="line">        <span class="comment">//3.数据库查询用户</span></span><br><span class="line">        User user = userService.findByName(username); </span><br><span class="line">        <span class="comment">//4.用户存在并且密码匹配存储用户数据</span></span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span> &amp;&amp; user.getPassword().equals(password)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPassword(),<span class="keyword">this</span>.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">//返回null会抛出异常，表明用户不存在或密码不匹配 </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shiro的配置：SecurityManager 是 Shiro 架构的心脏，用于协调内部的多个组件完成全部认证授权的过程，使用基于springboot的配置方式完成SecurityManager，Realm的装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//配置自定义的Realm</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomRealm <span class="title">getRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置安全管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(CustomRealm realm)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用默认的安全管理器</span></span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(realm);</span><br><span class="line">        <span class="comment">//将自定义的realm交给安全管理器统一调度管理 </span></span><br><span class="line">        securityManager.setRealm(realm); </span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Filter工厂，设置对应的过滤条件和跳转条件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shirFilter</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//1.创建shiro过滤器工厂</span></span><br><span class="line">         ShiroFilterFactoryBean filterFactory = <span class="keyword">new</span> ShiroFilterFactoryBean(); </span><br><span class="line">         <span class="comment">//2.设置安全管理器</span></span><br><span class="line">         filterFactory.setSecurityManager(securityManager); </span><br><span class="line">         <span class="comment">//3.通用配置(配置登录页面，登录成功页面，验证未成功页面)      </span></span><br><span class="line">         filterFactory.setLoginUrl(<span class="string">&quot;/autherror?code=1&quot;</span>); <span class="comment">//设置登录页面 </span></span><br><span class="line">         filterFactory.setUnauthorizedUrl(<span class="string">&quot;/autherror?code=2&quot;</span>); <span class="comment">//授权失败跳转页面 </span></span><br><span class="line">         <span class="comment">//4.配置过滤器集合</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* key :访问连接 支持通配符的形式</span></span><br><span class="line"><span class="comment">* value:过滤器类型 </span></span><br><span class="line"><span class="comment">* shiro常用过滤器</span></span><br><span class="line"><span class="comment">*     anno :匿名访问(表明此链接所有人可以访问)</span></span><br><span class="line"><span class="comment">*     authc :认证后访问(表明此链接需登录认证成功之后可以访问)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">         Map&lt;String,String&gt; filterMap = <span class="keyword">new</span> LinkedHashMap&lt;String,String&gt;(); <span class="comment">// 配置不会被拦截的链接 顺序判断</span></span><br><span class="line">         filterMap.put(<span class="string">&quot;/user/home&quot;</span>, <span class="string">&quot;anon&quot;</span>);</span><br><span class="line">         filterMap.put(<span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;authc&quot;</span>);</span><br><span class="line">         <span class="comment">//5.设置过滤器 </span></span><br><span class="line">         filterFactory.setFilterChainDefinitionMap(filterMap); </span><br><span class="line">         <span class="keyword">return</span> filterFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置shiro注解支持</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(SecurityManager securityManager)</span> </span>&#123;</span><br><span class="line">        AuthorizationAttributeSourceAdvisor advisor = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();                       ·      advisor.setSecurityManager(securityManager); <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>shiro中的过滤器:</p><table><thead><tr><th>Filter</th><th align="left">解释</th></tr></thead><tbody><tr><td><strong>anon</strong></td><td align="left">无参，开放权限，可以理解为匿名用户或游客</td></tr><tr><td><strong>authc</strong></td><td align="left">无参，需要认证</td></tr><tr><td>logout</td><td align="left">无参，注销，执行后会直接跳转到 shiroFilterFactoryBean.setLoginUrl(); 设置的 url</td></tr><tr><td>authcBasic</td><td align="left">无参，表示 httpBasic 认证</td></tr><tr><td>user</td><td align="left">无参，表示必须存在用户，当登入操作时不做检查</td></tr><tr><td>ssl</td><td align="left">无参，表示安全的URL请求，协议为 https</td></tr><tr><td><strong>perms[user]</strong></td><td align="left">参数可写多个，表示需要某个或某些权限才能通过，多个参数时写 perms[“user, admin”]，当有多个参数时必须每个参数都通过才算通过</td></tr><tr><td>roles[admin]</td><td align="left">参数可写多个，表示是某个或某些角色才能通过，多个参数时写 roles[“admin，user”]， 当有多个参数时必须每个参数都通过才算通过</td></tr><tr><td>rest[user]</td><td align="left">根据请求的方法，相当于 perms[user:method]，其中 method 为 post，get，delete 等</td></tr><tr><td>port[8081]</td><td align="left">当请求的URL端口不是8081时，跳转到当前访问主机HOST的8081端口</td></tr></tbody></table><blockquote><p>注意:anon, authc, authcBasic, user 是第一组认证过滤器，perms, port, rest, roles, ssl 是第二组授权过滤 器，要通过授权过滤器，就先要完成登陆认证操作(即先要完成认证才能前去寻找授权) 才能走第二组授权器 (例如访问需要 roles 权限的 url，如果还没有登陆的话，会直接跳转到 shiroFilterFactoryBean.setLoginUrl(); 设置的 url )</p></blockquote><p>基于配置的授权</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置请求连接过滤器配置</span></span><br><span class="line"><span class="comment">//匿名访问(所有人员可以使用) </span></span><br><span class="line">filterMap.put(<span class="string">&quot;/user/home&quot;</span>, <span class="string">&quot;anon&quot;</span>); </span><br><span class="line"><span class="comment">//具有指定权限访问</span></span><br><span class="line">filterMap.put(<span class="string">&quot;/user/find&quot;</span>, <span class="string">&quot;perms[user-find]&quot;</span>); </span><br><span class="line"><span class="comment">//认证之后访问(登录之后可以访问) </span></span><br><span class="line">filterMap.put(<span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;authc&quot;</span>); </span><br><span class="line"><span class="comment">//具有指定角色可以访问</span></span><br><span class="line">filterMap.put(<span class="string">&quot;/user/**&quot;</span>, <span class="string">&quot;roles[系统管理员]&quot;</span>);</span><br></pre></td></tr></table></figure><p>基于注解的授权</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)RequiresPermissions</span><br><span class="line"> <span class="comment">//查询</span></span><br><span class="line"><span class="meta">@RequiresPermissions(value = &quot;user-find&quot;)</span> <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;查询用户成功&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)RequiresRoles</span><br><span class="line"> <span class="comment">//查询</span></span><br><span class="line"><span class="meta">@RequiresRoles(value = &quot;系统管理员&quot;)</span> <span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;查询用户成功&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;导入依赖&lt;/li&gt;
&lt;li&gt;修改登录方法&lt;/li&gt;
&lt;li&gt;自定义Realm&lt;/li&gt;
&lt;li&gt;Shiro配置&lt;/li&gt;
&lt;li&gt;Shiro过滤器&lt;/li&gt;
&lt;li&gt;授权&lt;ul&gt;
&lt;li&gt;1基于配置授权&lt;/li&gt;
&lt;li&gt;2基于注解授权&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Shiro中的会话管理（怎样创建自己维护的会话）</title>
    <link href="http://example.com/2020/10/28/Shiro%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%88%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BC%9A%E8%AF%9D%EF%BC%89/"/>
    <id>http://example.com/2020/10/28/Shiro%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%EF%BC%88%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BC%9A%E8%AF%9D%EF%BC%89/</id>
    <published>2020-10-28T02:43:40.000Z</published>
    <updated>2020-10-28T03:01:13.203Z</updated>
    
    <content type="html"><![CDATA[<p>shiro提供了三个默认实现：</p><ol><li>DefaultSessionManager:用于JavaSE环境</li><li>ServletContainerSessionManager:用于Web环境，直接使用servlet容器的会话。</li><li>DefaultWebSessionManager:用于web环境，自己维护会话(自己维护着会话，直接废弃了Servlet容器的会话管理)。</li></ol><p>在web程序中，通过shiro的Subject.login()方法登录成功后，用户的认证信息实际上是保存在HttpSession中的</p><p>Shiro结合redis的统一会话管理</p><p>构建环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//导入依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.crazycake<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//在springboot配置文件中添加redis配置</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">   <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> </span><br><span class="line">   <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>自定义shiro会话管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自定义的sessionManager 继承DefaultWebSessionManager</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSessionManager</span> <span class="keyword">extends</span> <span class="title">DefaultWebSessionManager</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 头信息中具有sessionid</span></span><br><span class="line"><span class="comment">* 请求头:Authorization: sessionid *</span></span><br><span class="line"><span class="comment">* 指定sessionId的获取方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Serializable <span class="title">getSessionId</span><span class="params">(ServletRequest request, ServletResponse</span></span></span><br><span class="line"><span class="function"><span class="params">    response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取请求头Authorization中的数据</span></span><br><span class="line">        String id = WebUtils.toHttp(request).getHeader(<span class="string">&quot;Authorization&quot;</span>); </span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(id)) &#123;</span><br><span class="line">            <span class="comment">//如果没有携带，生成新的sessionId</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSessionId(request,response); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//返回sessionId; </span></span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,<span class="string">&quot;header&quot;</span>);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);</span><br><span class="line">            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置Shiro基于redis的会话管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 配置shiro的RedisManager，通过shiro-redis包提供的RedisManager统一对redis操作 </span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.redis.host&#125;&quot;)</span> <span class="keyword">private</span> String host;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.redis.port&#125;&quot;)</span> <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"><span class="comment">//配置shiro redisManager</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisManager <span class="title">redisManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisManager redisManager = <span class="keyword">new</span> RedisManager(); </span><br><span class="line">    redisManager.setHost(host); </span><br><span class="line">    redisManager.setPort(port);</span><br><span class="line"><span class="keyword">return</span> redisManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> Shiro内部有自己的本地缓存机制，为了更加统一方便管理，全部替换redis实现</span><br><span class="line"> <span class="comment">//配置Shiro的缓存管理器</span></span><br><span class="line"><span class="comment">//使用redis实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager();    </span><br><span class="line">    redisCacheManager.setRedisManager(redisManager());</span><br><span class="line">    <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span> 配置SessionDao，使用shiro-redis实现的基于redis的sessionDao</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* RedisSessionDAO shiro sessionDao层的实现 通过redis </span></span><br><span class="line"><span class="comment">* 使用的是shiro-redis开源插件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisSessionDAO <span class="title">redisSessionDAO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisSessionDAO redisSessionDAO = <span class="keyword">new</span> RedisSessionDAO(); </span><br><span class="line">    redisSessionDAO.setRedisManager(redisManager()); </span><br><span class="line">    <span class="keyword">return</span> redisSessionDAO;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4.</span> 配置会话管理器，指定sessionDao的依赖关系</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* 3.会话管理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DefaultWebSessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    CustomSessionManager sessionManager = <span class="keyword">new</span>   CustomSessionManager();      </span><br><span class="line">    sessionManager.setSessionDAO(redisSessionDAO());</span><br><span class="line">    <span class="keyword">return</span> sessionManager;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5.</span> 统一交给SecurityManager管理</span><br><span class="line"> <span class="comment">//配置安全管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityManager <span class="title">securityManager</span><span class="params">(CustomRealm realm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用默认的安全管理器</span></span><br><span class="line">    DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager(realm);</span><br><span class="line">    <span class="comment">// 自定义session管理 使用redis </span></span><br><span class="line">    securityManager.setSessionManager(sessionManager()); </span><br><span class="line">    <span class="comment">// 自定义缓存实现 使用redis </span></span><br><span class="line">    securityManager.setCacheManager(cacheManager()); </span><br><span class="line">    <span class="comment">//将自定义的realm交给安全管理器统一调度管理 </span></span><br><span class="line">    securityManager.setRealm(realm);</span><br><span class="line">    <span class="keyword">return</span> securityManager;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;shiro提供了三个默认实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DefaultSessionManager:用于JavaSE环境&lt;/li&gt;
&lt;li&gt;ServletContainerSessionManager:用于Web环境，直接使用servlet容器的会话。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>导入依赖出现循环报错</title>
    <link href="http://example.com/2020/10/28/%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2020/10/28/%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E6%8A%A5%E9%94%99/</id>
    <published>2020-10-28T02:43:22.000Z</published>
    <updated>2020-10-28T02:58:42.387Z</updated>
    
    <content type="html"><![CDATA[<p>Error:java: Annotation processing is not supported for module cycles. Please ensure that all modules</p><p>分析：cycle [qrcode-common,qrcode-manager-pojo] ：从这里可以看出，qrcode-common,qrcode-manager-pojo这两个模块有问题，即互相依赖，类似死循环</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Error:java: Annotation processing is not supported for module cycles. Please ensure that all modules&lt;/p&gt;
&lt;p&gt;分析：cycle [qrcode-common,qrcod</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>使用umi build出现的Path must be a string恶心解决方法</title>
    <link href="http://example.com/2020/10/28/%E4%BD%BF%E7%94%A8umi-build%E5%87%BA%E7%8E%B0%E7%9A%84Path-must-be-a-string%E6%81%B6%E5%BF%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2020/10/28/%E4%BD%BF%E7%94%A8umi-build%E5%87%BA%E7%8E%B0%E7%9A%84Path-must-be-a-string%E6%81%B6%E5%BF%83%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2020-10-28T02:42:09.000Z</published>
    <updated>2020-10-28T02:58:09.004Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h1><p>按照官网升级umi-plugin-react的版本就完事，很多博客就写了个简单的文字叙述，具体怎么做也没做具体说明，出现这个错误的原因应该是umi插件版本与umi的版本有冲突，现在直接使用命令安装umi的话，系统都会默认给你安装最新版umi3，而umi3已经对原来的插件进行了更新，所以如果你的umi是最新版的，就要参考官方文档最新版的配置方式，不能一味地使用原来的配置，否则会一直报错。技术更新快，几个月前的新技术，在今天可能已经更新几个版本了，所以有问题，记得多看官方说明文档。</p><p>改完一定要重新导入依赖才能进行build！！！</p><p>官网：<a href="https://umijs.org/docs/upgrade-to-umi-3#%E5%8D%87%E7%BA%A7-umi-plugin-react-%E4%B8%BA-umijspreset-react">https://umijs.org/docs/upgrade-to-umi-3#%E5%8D%87%E7%BA%A7-umi-plugin-react-%E4%B8%BA-umijspreset-react</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;解决方法：&quot;&gt;&lt;a href=&quot;#解决方法：&quot; class=&quot;headerlink&quot; title=&quot;解决方法：&quot;&gt;&lt;/a&gt;解决方法：&lt;/h1&gt;&lt;p&gt;按照官网升级umi-plugin-react的版本就完事，很多博客就写了个简单的文字叙述，具体怎么做也没做具体说明，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker创建启动percona(mysql)闪退问题</title>
    <link href="http://example.com/2020/10/28/docker%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8percona-mysql-%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/10/28/docker%E5%88%9B%E5%BB%BA%E5%90%AF%E5%8A%A8percona-mysql-%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-28T02:41:31.000Z</published>
    <updated>2020-10-28T02:57:23.057Z</updated>
    
    <content type="html"><![CDATA[<p>#创建容器<br>docker create –name percona -v /data/mysql-data:/var/lib/mysql -p 3306:3306 -eMYSQL_ROOT_PASSWORD=root percona:5.7.23</p><p>docker start percona 直接闪退</p><p>因为/data目录没有访问权限</p><p>开启权限 chomd -R 777 data</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#创建容器&lt;br&gt;docker create –name percona -v /data/mysql-data:/var/lib/mysql -p 3306:3306 -eMYSQL_ROOT_PASSWORD=root percona:5.7.23&lt;/p&gt;
&lt;p&gt;doc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于SpringBoot启动某Service实现类报错发现两个实例问题</title>
    <link href="http://example.com/2020/10/24/%E5%85%B3%E4%BA%8ESpringBoot%E5%90%AF%E5%8A%A8%E6%9F%90Service%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%8A%A5%E9%94%99%E5%8F%91%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/10/24/%E5%85%B3%E4%BA%8ESpringBoot%E5%90%AF%E5%8A%A8%E6%9F%90Service%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%8A%A5%E9%94%99%E5%8F%91%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-24T09:08:25.000Z</published>
    <updated>2020-10-28T02:50:26.087Z</updated>
    
    <content type="html"><![CDATA[<p>问题如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceImpl required a single bean, but <span class="number">2</span> were found;</span><br></pre></td></tr></table></figure><p>原因是写了两个实现类继承某父类，而其中一个写了泛型，一个没写所以报错，部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseServiceImpl</span> <span class="keyword">implements</span> <span class="title">AdService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分页查询广告  </span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageInfo&lt;Ad&gt; <span class="title">queryAdList</span><span class="params">(Ad ad, Integer page, Integer pageSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//逻辑代码</span></span><br><span class="line">      <span class="comment">//返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseResourcesServiceImpl</span> <span class="keyword">extends</span> <span class="title">BaseServiceImpl</span>&lt;<span class="title">HouseResources</span>&gt; <span class="keyword">implements</span> <span class="title">HouseResourcesService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出第一个实现类继承的BaseServiceImpl没有泛型，第二个存在，然后就报错了。改为对应的泛型就好了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于SpringBoot启动报错DataSource问题</title>
    <link href="http://example.com/2020/10/24/%E5%85%B3%E4%BA%8ESpringBoot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99DataSource%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/10/24/%E5%85%B3%E4%BA%8ESpringBoot%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99DataSource%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-24T09:07:05.000Z</published>
    <updated>2020-10-24T09:54:44.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Springboot启动时报错-If-you-want-an-embedded-database-H2-HSQL-or-Derby-please-put-it-on-the-classpath"><a href="#Springboot启动时报错-If-you-want-an-embedded-database-H2-HSQL-or-Derby-please-put-it-on-the-classpath" class="headerlink" title="Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), please put it on the classpath."></a>Springboot启动时报错 If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</h2><p>产生这个错误的原因是springboot的自动配置，如果你没有配置DataSource就会导致这个错误</p><p>版本一：解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><span class="comment">//排除自动配置</span></span><br></pre></td></tr></table></figure><p>关于exclude属性和DataSource问题</p><p>exclude属性是@SpringBootApplication注解中的@EnableAutoConfiguration属性 排除某个类的自动配置</p><p>在本例中，datasource没有配置所以启动时报错</p><p>版本二：上述问题又出现了一次这次按版本一没有成功，在网上找了很多答案,</p><p>其中的一篇:<a href="https://www.cnblogs.com/yourGod/p/9178515.html">https://www.cnblogs.com/yourGod/p/9178515.html</a></p><p>按照上述的解决办法:)</p><p>版本一这样之后还会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Description:</span><br><span class="line">Field userRepository in com.wcyq.demo.service.impl.UserServiceImpl required a bean of type &#39;com.wcyq.demo.domain.UserRepository&#39; that could not be found.</span><br><span class="line">Action:</span><br><span class="line">Consider defining a bean of type &#39;com.wcyq.demo.domain.UserRepository&#39; in your configuration.</span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><blockquote><p>这样dao就找不到了</p><p>最后解决办法是application.yml文件配置改变一下</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: ihrm-company</span><br><span class="line">datasource:</span><br><span class="line">url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ihrm?characterEncoding&#x3D;utf-8</span><br><span class="line">username: root</span><br><span class="line">password: root</span><br><span class="line">driverClassName: com.mysql.jdbc.Driver</span><br><span class="line">改为下面的 加了druid连接</span><br><span class="line">spring:</span><br><span class="line">application:</span><br><span class="line">name: ihrm-company</span><br><span class="line">datasource:</span><br><span class="line">druid:</span><br><span class="line">url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;ihrm?characterEncoding&#x3D;utf-8</span><br><span class="line">username: root</span><br><span class="line">password: root</span><br><span class="line">driverClassName: com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>是yml文件出现了问题，在此记录一下</p><hr><p>最后总结一下，导入了和数据库连接的依赖就要考虑你的datasource问题，如果需要就在配置文件中配置好，SpringBoot会自动导入；如果不需要，把exclude写上，或者依赖删掉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Springboot启动时报错-If-you-want-an-embedded-database-H2-HSQL-or-Derby-please-put-it-on-the-classpath&quot;&gt;&lt;a href=&quot;#Springboot启动时报错-If-you-w</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>关于Spring组件未加人到容器报错问题</title>
    <link href="http://example.com/2020/10/21/%E5%85%B3%E4%BA%8ESpring%E7%BB%84%E4%BB%B6%E6%9C%AA%E5%8A%A0%E4%BA%BA%E5%88%B0%E5%AE%B9%E5%99%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2020/10/21/%E5%85%B3%E4%BA%8ESpring%E7%BB%84%E4%BB%B6%E6%9C%AA%E5%8A%A0%E4%BA%BA%E5%88%B0%E5%AE%B9%E5%99%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-21T07:12:27.000Z</published>
    <updated>2020-10-21T07:13:28.583Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">问题描述：The injection point has the following annotations:</span><br><span class="line">- @org.springframework.beans.factory.annotation.Autowired(required&#x3D;true)</span><br><span class="line">Action:</span><br></pre></td></tr></table></figure><p>原因是自己在写项目时不小心把Spring的Service组件忘记加注解了，导致没有导入到spring容器中，而另一个类引用了该组件，启动时找不到，所以报错。</p><p>以后出现这种错误可以猜测到是Spring的某个@Autowired注解下的组件未导入到容器中。。</p><p>在此记录一下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
</feed>
